# 线程

## Sychronized

~~~bash
1、锁方法
2、锁代码块
锁代码块的时候，是monitorenter和moitorexit指令来实现同步的，进入monitorenter，那就是加锁，然后monitorexit，就是释放锁

锁方法的时候，是有个ACC_SYNCHRONIZED方法标志，是通过这个标志来进行加锁和释放锁

JVM中的同步是基于进入和退出管程(对象)来实现的，这个管程是个重点，我们的aqs，reentrantlock就是基于管程的
它内部是有2个队列，一个fifo队列，chl，一个condition队列，等待被换线进入fifo队列

话题说回来这个sychronized关键字：当多个线程同时访问一段被同步的代码时，
多个线程会放在EntryList集合中，这个是不是可以类比aqs中的那个fifo队列，然后就开始等待获取monitor，
如果线程调用wait方法，释放了锁，那么线程会进入waitset集合中，等待下一次被唤醒，可以类比asq中的condition队列
~~~

![image-20220608172054435](C:\Users\wangyh\AppData\Roaming\Typora\typora-user-images\image-20220608172054435.png)

~~~bash
java1.6之后，对shchronized进行了锁优化，引入了无锁、偏向锁、轻量级锁、重量级锁的概念，来减少锁竞争带来的上下文切换，这些都是跟着我们的java对象头关联起来的
那我们这边说到了java对象头，有一个经典的问题，我们java new一个空的object对象，它占几个字节，这里我们以64位系统为例：对象分为对象头、实例数据和补充部分，要补齐至8的倍数，对象头里面有两部分，一个是classpointer，一个是markword，mw是8，cp是4，那么这就12了，就算你空的，你补齐也要16个字节
~~~

![image-20220608173701071](C:\Users\wangyh\AppData\Roaming\Typora\typora-user-images\image-20220608173701071.png)

~~~bash
再说回来shchronized这边，锁升级功能主要是依赖于markword中的锁标志位和释放偏向锁标志位，那我们现在的shchronized同步锁就是从偏向锁开始，随着竞争条件，升级至轻量级锁，最终到重量级锁
~~~

![image-20220608174012549](C:\Users\wangyh\AppData\Roaming\Typora\typora-user-images\image-20220608174012549.png)

### 偏向锁

~~~bash
偏向锁主要用来优化同一线程多次申请同一个锁的竞争
场景：创建一个线程并在线程中执行循环监听，或单线程操作一个线程安全的集合时，同一线程每次都需要获取和释放锁，每次操作都会发生用户态与内核态的切换
偏向锁就是说，当一个线程再次访问同步代码块或方法时，该线程去对象头的markword中去判断一下是否有偏向锁指向他的id，无需再进入之前的那个entryset队列去竞争对象了，大家发现没有，这个是个不公平的锁

此时"锁标志位" 01，"是否偏向锁"1

如果此时一旦出现其它线程竞争锁资源，偏向锁就要被撤销，到达安全点，并发生"stop-the-world，"
同时检查原线程是否还执行该方法，如果执行，那么我们直接升级锁，就到了轻量级锁，反之被其它线程抢占

能看出来在高并发场景下，当大量线程同时竞争同一个锁资源时，偏向锁就会被撤销，发生"s-t-w"后，开启偏向锁无疑来说会带来更大的性能开销，"一般我们是通过jvm参数关闭掉偏向锁来调优"
-XX:-UseBiasedLocking  // 默认打开，我们关闭
-XX:+UseHeavyMonitors  // 设置重量级锁
~~~

### 轻量级锁

~~~bash
当有另外一个线程竞争锁时，由于发现这个锁已经是偏向锁了，markword中的线程id不是自己的线程id，就会进行cas操作来获取锁，如果获取成功，直接替换markword中的线程id为自己的id，该锁还是偏向锁状态；
如果获取锁失败，代表当前锁有一定的竞争，偏向锁升级为轻量级锁
问题就在这边，获取的时候，原来的占用偏向锁的进行要进去安全点，然后会发生stop-the-world，朋友们，这个是很严重的事情了

轻量级锁适用于线程交替执行同步块的场景，绝大部分的锁在整个同步周期内都不存在长时间的竞争
~~~

### 自旋锁与重量级锁

~~~bash
轻量级锁cas抢锁失败，线程将会被挂起进入阻塞状态，如果说自旋锁重试之后还是说抢锁失败，那么我们同步锁会升级至重量级锁，锁标志位改为10，这个时候，未抢到锁的线程会进入monitor，之后被阻塞在waitset队列中

在高负载、高并发的场景下，直接通过JVM参数来关闭自旋锁，优化系统性能
-XX:-UseSpinning //参数关闭自旋锁优化
~~~

### 动态编译实现锁消除/锁粗化

~~~bash
动态编译，如果发现几个相邻的同步块使用的是同一个锁实例，那么会把这几个同步块合并成一个大的同步块，避免一个线程反复申请、释放一个锁带来的性能开销
~~~

### 减小锁粒度

~~~bash
这个一般是我们通过代码层面来实现锁优化，减小锁粒度就是一种惯用的方法

考虑将一个数组和队列对象拆成多个小对象，来降低锁竞争，提升并行度
JDK1.8之前实现的ConcurrentHashMap，使用分段锁Segment来降低锁资源竞争
~~~

![image-20220609092515631](C:\Users\wangyh\AppData\Roaming\Typora\typora-user-images\image-20220609092515631.png)

